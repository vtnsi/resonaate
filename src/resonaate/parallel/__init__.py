"""A widely-applicable interface for parallel task execution in Python.

This design uses a :class:`.QueueManager` to make use of a concept called a `Redis`_ `Task Queue`_
to schedule serialized :class:`.Task` s across multiple :meth:`.worker_loop()` s that are managed by
one or more :class:`.WorkerManager` s.

In this ``__init__.py`` file, several package-level constants and functions are defined.

.. _Redis:
    https://redis.io/
.. _Task Queue:
    https://redislabs.com/ebook/part-2-core-concepts/chapter-6-application-components-in-redis/6-4-task-queues/
"""
import logging
import os
from sys import stdout
from uuid import uuid4
from redis import Redis
from ..common.behavioral_config import BehavioralConfig

TASK_QUEUE_LIST = 'task_queue_list'
"""str: Key to use when accessing list of registered task queues."""

TASK_QUEUE_NAME_PREFIX = 'task_queue_'
"""str: Key to use when accessing ``redis`` task queue."""

PROCESSED_QUEUE_NAME_PREFIX = 'processed_task_queue_'
"""str: Key to use when accessing redis processed task queue."""

MASTER_KEY_NAME = 'master'
"""str: Key to use for indication of whether the current instance is master."""

MASTER_HASH = None
"""None | str: Master hash generated by this instance or ``None`` if it hasn't generated a hash."""


class _RedisConfig:
    """Singleton class to contain Redis configuration."""

    REDIS_HOSTNAME = None
    """str: Hostname of ``redis`` server to connect to."""
    REDIS_PORT = None
    """int: Port of ``redis`` server to connect to."""
    REDIS_PASSWORD = None
    """str: Password to use when connecting to the ``redis`` server."""

    __shared_inst = None

    def __init__(self, hostname=None, port=None, password=None):
        if hostname is None:
            hostname = BehavioralConfig.getConfig().parallel.RedisHostname
        if port is None:
            port = BehavioralConfig.getConfig().parallel.RedisPort
        if password is None:
            password = os.getenv("REDIS_PASSWORD")

        # pylint: disable=invalid-name
        self.REDIS_HOSTNAME = hostname
        self.REDIS_PORT = port
        self.REDIS_PASSWORD = password

    def setDefaultConnectionParameters(self, hostname, port, password):
        """Set the default ``redis`` server connection parameters.

        Args:
            hostname (str, optional): New hostname value.
            port(int, optional): New port value.
            password(str, optional): New password value.
        """
        if isinstance(hostname, str):
            self.REDIS_HOSTNAME = hostname
        else:
            raise TypeError("New hostname argument must be of type 'str', not '{0}'".format(type(hostname)))

        if isinstance(port, int):
            self.REDIS_PORT = port
        else:
            raise TypeError("New port argument must be of type 'int', not '{0}'".format(type(port)))

        if isinstance(password, str):
            self.REDIS_PASSWORD = password
        else:
            raise TypeError("New password argument must be of type 'str', not '{0}'".format(type(password)))

    @classmethod
    def getConfig(cls, hostname=None, port=None, password=None):
        """Return a reference to the singleton Redis config."""
        if cls.__shared_inst is None:
            cls.__shared_inst = _RedisConfig(hostname, port, password)

        return cls.__shared_inst


REDIS_SINGLETON = None


def getRedisConnection(host=None, port=None, password=None):
    """Factory method that returns a connection to the ``redis`` server.

    Args:
        hostname (str, optional): Hostname of ``redis`` server to connect to.
        port(int, optional): Port that ``redis`` server is running on.
        password(str, optional): Password used to authenticate on ``redis`` server.
    """
    global REDIS_SINGLETON  # pylint: disable=global-statement
    config = _RedisConfig.getConfig(hostname=host, port=port, password=password)

    if REDIS_SINGLETON is None:
        REDIS_SINGLETON = Redis(
            host=config.REDIS_HOSTNAME,
            port=config.REDIS_PORT,
            password=config.REDIS_PASSWORD
        )

    return REDIS_SINGLETON


def resetRedisQueue(redis_connection, queue_name):
    """Remove all contents of a ``redis`` queue.

    Args:
        redis_connection (redis.Redis): Instantiated connection to a Redis server.
        queue_name (str): Key used to access queue to reset.

    Returns:
        int: Number of items removed from queue.
    """
    rem_count = 0
    while redis_connection.rpop(queue_name) is not None:
        rem_count += 1

    return rem_count


def isMaster(redis_connection=None):
    """Determine if the instance running is a master or a slave instance.

    Check if the 'master' key on the ``redis`` server is set. If not, set it to a unique string and
    assume responsibilities of the master instance. Otherwise, this instance is not master.

    Args:
        redis_connection (Redis, optional): ``redis`` connection. If this isn't provided, this
            method will create its own connection using :meth:`.getRedisConnection()` .

    Returns:
        bool: Boolean indicating whether this instance is master.
    """
    red = None
    if isinstance(redis_connection, Redis):
        red = redis_connection
    else:
        red = getRedisConnection()

    global MASTER_HASH  # pylint: disable=global-statement
    if MASTER_HASH is None:
        MASTER_HASH = str(uuid4())

    wasnt_set = red.setnx(MASTER_KEY_NAME, MASTER_HASH)

    if wasnt_set:
        return True
    else:
        redis_master = red.get(MASTER_KEY_NAME).decode('utf-8')

        return redis_master == MASTER_HASH


def masterExists(redis_connection=None):
    """Determine whether a master instance currently exists.

    This design relies on the master instance to call :meth:`.resetMaster()` when it exits, so that
    slave instances can use this method as an indication to continue checking for tasks or to exit.

    Args:
        redis_connection (Redis, optional): ``redis`` connection. If this isn't provided, this
            method will create its own connection using :meth:`.getRedisConnection()` .

    Returns:
        bool: Boolean indicating whether a master currently exists.
    """
    red = None
    if isinstance(redis_connection, Redis):
        red = redis_connection
    else:
        red = getRedisConnection()

    return red.exists(MASTER_KEY_NAME)


def resetMaster(redis_connection=None):
    """Clear the master key on the ``redis`` server.

    This method should be used by a master instance when that master instance is exiting to
    indicate that it is no longer master.

    Args:
        redis_connection (Redis, optional): ``redis`` connection. If this isn't provided, this
            method will create its own connection using :meth:`.getRedisConnection()` .
    """
    red = None
    if isinstance(redis_connection, Redis):
        red = redis_connection
    else:
        red = getRedisConnection()

    red.delete(MASTER_KEY_NAME)


def getMasterHash():
    """Retrieve the value set for :attr:`.MASTER_HASH` ."""
    global MASTER_HASH  # pylint: disable=global-statement
    return MASTER_HASH


REDIS_QUEUE_LOGGER = logging.getLogger(__name__)


def setUpLogger(destination='stdout'):
    """Set up the default loggin instance.

    Note:
        It's necessary to call this method before making any logging calls to
        :attr:`.REDIS_QUEUE_LOGGER` because otherwise it will be a *very* default logger which logs
        at level ``NOTSET`` to ``stderr`` .

    Args:
        destination (str): Configure the default logger to log to file ('file') or ``sys.stdout``
            ('stdout').
    """
    if not REDIS_QUEUE_LOGGER.hasHandlers():
        if destination == "stdout":
            handler = logging.StreamHandler(stream=stdout)

        elif destination == "file":
            if isMaster():
                filename = "master-{0}.log".format(MASTER_HASH[:8])
            else:
                filename = "slave-{0}.log".format(MASTER_HASH[:8])
            handler = logging.FileHandler(filename)

        else:
            err = "'_LOGGING_LOCATION' can't be set to '{0}'".format(destination)
            raise ValueError(err)

        handler.setFormatter(logging.Formatter('%(asctime)s - %(module)s - %(levelname)s - %(message)s'))
        REDIS_QUEUE_LOGGER.addHandler(handler)
        REDIS_QUEUE_LOGGER.setLevel(logging.DEBUG)
