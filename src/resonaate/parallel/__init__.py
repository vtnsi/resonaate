"""A widely-applicable interface for parallel job execution in Python.

This design uses a :class:`.QueueManager` to make use of a concept called a `Redis`_ `Task Queue`_
to schedule serialized :class:`.Job` s across multiple :meth:`.worker_loop()` s that are managed by
one or more :class:`.WorkerManager` s.

In this ``__init__.py`` file, several package-level constants and functions are defined.

.. _Redis:
    https://redis.io/
.. _Task Queue:
    https://redislabs.com/ebook/part-2-core-concepts/chapter-6-application-components-in-redis/6-4-task-queues/
"""
# Standard Library Imports
import logging
import os
import sys
from abc import ABC, abstractmethod
from uuid import uuid4

# Third Party Imports
from redis import Redis
from redis import exceptions as redis_exceptions

# Local Imports
from ..common.behavioral_config import BehavioralConfig

JOB_QUEUE_LIST = "job_queue_list"
"""``str``: Key to use when accessing list of registered job queues."""

JOB_QUEUE_NAME_PREFIX = "job_queue_"
"""``str``: Key to use when accessing ``redis`` job queue."""

PROCESSED_QUEUE_NAME_PREFIX = "processed_job_queue_"
"""``str``: Key to use when accessing redis processed job queue."""

MASTER_KEY_NAME = "master"
"""``str``: Key to use for indication of whether the current instance is master."""

MASTER_HASH = None
"""``None`` | ``str``: Master hash generated by this instance or ``None`` if it hasn't generated a hash."""


class ParallelMixin(ABC):
    """Class which provides an interface for all parallel-related classes.

    This class is intended to be subclassed by a class which contains parallel processing
    code. The purpose it to enforce good practices for parallel processing by requiring
    certain methods be explicitly defined.
    """

    @abstractmethod
    def shutdown(self):
        """Properly shutdown the parallel processing jobs & managers.

        This method should be called once the class is no longer used. This method must be
        overridden by all subclasses. The defined method should call any necessary shutdown
        logic internal to the class, including calling :meth:`.shutdown` on any contained classes.
        """
        raise NotImplementedError


class RedisConfig:
    """Singleton class to contain Redis configuration.

    Attributes:
        redis_hostname (``str``): Hostname of ``redis`` server to connect to.
        redis_port (``int``): Port of ``redis`` server to connect to.
        redis_password (``str``): Password to use when connecting to the ``redis`` server.
    """

    __shared_inst = None

    def __init__(self, hostname=None, port=None, password=None):
        """Create instance of Redis configuration.

        Args:
            hostname (``str``, optional): Hostname of ``redis`` server to connect to. Defaults to None.
            port (``int``, optional): Port of ``redis`` server to connect to. Defaults to None.
            password (``str``, optional): Password used when connecting to the ``redis`` server. Defaults to None.
        """
        if hostname is None:
            hostname = BehavioralConfig.getConfig().parallel.RedisHostname
        if port is None:
            port = BehavioralConfig.getConfig().parallel.RedisPort
        if password is None:
            password = os.getenv("REDIS_PASSWORD")

        # pylint: disable=invalid-name
        self.redis_hostname = hostname
        self.redis_port = port
        self.redis_password = password

    def setDefaultConnectionParameters(self, hostname, port, password):
        """Set the default ``redis`` server connection parameters.

        Args:
            hostname (``str``, optional): New hostname value.
            port (``int``, optional): New port value.
            password (``str``, optional): New password value.
        """
        if isinstance(hostname, str):
            self.redis_hostname = hostname
        else:
            raise TypeError(f"New hostname argument must be of type 'str', not '{type(hostname)}'")

        if isinstance(port, int):
            self.redis_port = port
        else:
            raise TypeError(f"New port argument must be of type 'int', not '{type(port)}'")

        if isinstance(password, str):
            self.redis_password = password
        else:
            raise TypeError(f"New password argument must be of type 'str', not '{type(password)}'")

    @classmethod
    def getConfig(cls, hostname=None, port=None, password=None):
        """Return a reference to the singleton Redis config."""
        if cls.__shared_inst is None:
            cls.__shared_inst = cls(hostname, port, password)

        return cls.__shared_inst


REDIS_SINGLETON = None


def getRedisConnection(hostname=None, port=None, password=None):
    """Factory method that returns a connection to the ``redis`` server.

    Args:
        hostname (``str``, optional): Hostname of ``redis`` server to connect to.
        port (``int``, optional): Port that ``redis`` server is running on.
        password (``str``, optional): Password used to authenticate on ``redis`` server.
    """
    global REDIS_SINGLETON  # pylint: disable=global-statement
    config = RedisConfig.getConfig(hostname=hostname, port=port, password=password)

    if REDIS_SINGLETON is None:
        REDIS_SINGLETON = Redis(
            host=config.redis_hostname, port=config.redis_port, password=config.redis_password
        )

    return REDIS_SINGLETON


def resetRedisQueue(redis_connection, queue_name):
    """Remove all contents of a ``redis`` queue.

    Args:
        redis_connection (``redis.Redis``): Instantiated connection to a Redis server.
        queue_name (``str``): Key used to access queue to reset.

    Returns:
        int: Number of items removed from queue.
    """
    rem_count = 0
    while redis_connection.rpop(queue_name) is not None:
        rem_count += 1

    return rem_count


def isMaster(redis_connection=None):
    """Determine if the instance running is a master or a slave instance.

    Check if the 'master' key on the ``redis`` server is set. If not, set it to a unique string and
    assume responsibilities of the master instance. Otherwise, this instance is not master.

    Args:
        redis_connection (``Redis``, optional): ``redis`` connection. If this isn't provided, this
            method will create its own connection using :meth:`.getRedisConnection()` .

    Returns:
        ``bool``: Boolean indicating whether this instance is master.
    """
    red = None
    if isinstance(redis_connection, Redis):
        red = redis_connection
    else:
        red = getRedisConnection()

    global MASTER_HASH  # pylint: disable=global-statement
    if MASTER_HASH is None:
        MASTER_HASH = str(uuid4())

    try:
        wasnt_set = red.setnx(MASTER_KEY_NAME, MASTER_HASH)
    except redis_exceptions.ConnectionError as err:
        setUpLogger()
        REDIS_QUEUE_LOGGER.error("Redis server was not started, or pointing to a different port.")
        raise err

    if wasnt_set:
        return True

    redis_master = red.get(MASTER_KEY_NAME).decode("utf-8")
    return redis_master == MASTER_HASH


def masterExists(redis_connection=None):
    """Determine whether a master instance currently exists.

    This design relies on the master instance to call :meth:`.resetMaster()` when it exits, so that
    slave instances can use this method as an indication to continue checking for jobs or to exit.

    Args:
        redis_connection (``Redis``, optional): ``redis`` connection. If this isn't provided, this
            method will create its own connection using :meth:`.getRedisConnection()` .

    Returns:
        ``bool``: Boolean indicating whether a master currently exists.
    """
    red = None
    if isinstance(redis_connection, Redis):
        red = redis_connection
    else:
        red = getRedisConnection()

    return red.exists(MASTER_KEY_NAME) == 1


def resetMaster(redis_connection=None):
    """Clear the master key on the ``redis`` server.

    This method should be used by a master instance when that master instance is exiting to
    indicate that it is no longer master.

    Args:
        redis_connection (``Redis``, optional): ``redis`` connection. If this isn't provided, this
            method will create its own connection using :meth:`.getRedisConnection()`.

    Returns:
        ``bool``: Boolean indicating whether the master key was actually deleted.
    """
    red = None
    if isinstance(redis_connection, Redis):
        red = redis_connection
    else:
        red = getRedisConnection()

    return red.delete(MASTER_KEY_NAME) == 1


def getMasterHash():
    """Retrieve the value set for :attr:`.MASTER_HASH` ."""
    global MASTER_HASH  # pylint: disable=global-variable-not-assigned
    return MASTER_HASH


REDIS_QUEUE_LOGGER = logging.getLogger(__name__)


DEFAULT_REDIS_LOGGER_LOCATION = BehavioralConfig.getConfig().logging.OutputLocation
"""``str``: default location of where to log Redis information."""


def setUpLogger(destination=DEFAULT_REDIS_LOGGER_LOCATION):
    """Set up the default logging instance.

    Note:
        It's necessary to call this method before making any logging calls to
        :attr:`.REDIS_QUEUE_LOGGER` because otherwise it will be a *very* default logger which logs
        at level ``NOTSET`` to ``stderr`` .

    Args:
        destination (``str``): Configure the default logger to log to file ('file') or ``sys.stdout``
            ('stdout').
    """
    if not REDIS_QUEUE_LOGGER.hasHandlers():
        if destination == "stdout":
            handler = logging.StreamHandler(stream=sys.stdout)

        else:
            # Create the path if it doesn't exist.
            if not os.path.exists(destination):
                print(f"Path did not exist: '{destination}'. Creating path...")
                os.makedirs(destination)

            if isMaster():
                filename = f"master-{MASTER_HASH[:8]}.log"
            else:
                filename = f"slave-{MASTER_HASH[:8]}.log"
            handler = logging.FileHandler(os.path.join(destination, filename))

        handler.setFormatter(
            logging.Formatter(
                "%(asctime)s - %(module)s - %(funcName)s() - %(levelname)s - %(message)s"
            )
        )
        REDIS_QUEUE_LOGGER.addHandler(handler)
        REDIS_QUEUE_LOGGER.setLevel(logging.DEBUG)
